function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

import { Layer } from '@deck.gl/core';
import { Model, Geometry } from 'luma.gl';
import tripsVertex from './trips-layer-vertex.glsl';
import tripsFragment from './trips-layer-fragment.glsl';
var defaultProps = {
  trailLength: 120,
  currentTime: 0,
  getPath: function getPath(d) {
    return d.path;
  },
  getColor: function getColor(d) {
    return d.color;
  }
};

var TripsLayer =
/*#__PURE__*/
function (_Layer) {
  _inherits(TripsLayer, _Layer);

  function TripsLayer() {
    _classCallCheck(this, TripsLayer);

    return _possibleConstructorReturn(this, _getPrototypeOf(TripsLayer).apply(this, arguments));
  }

  _createClass(TripsLayer, [{
    key: "initializeState",
    value: function initializeState() {
      var gl = this.context.gl;
      var attributeManager = this.getAttributeManager();
      var model = this.getModel(gl);
      attributeManager.add({
        indices: {
          size: 1,
          update: this.calculateIndices,
          isIndexed: true
        },
        positions: {
          size: 3,
          update: this.calculatePositions
        },
        colors: {
          size: 3,
          accessor: 'getColor',
          update: this.calculateColors
        }
      });
      gl.getExtension('OES_element_index_uint');
      this.setState({
        model: model
      });
    }
  }, {
    key: "updateState",
    value: function updateState(_ref) {
      var props = _ref.props,
          dataChanged = _ref.changeFlags.dataChanged;

      if (dataChanged) {
        this.countVertices(props.data);
        this.state.attributeManager.invalidateAll();
      }
    }
  }, {
    key: "getModel",
    value: function getModel(gl) {
      return new Model(gl, {
        id: this.props.id,
        vs: tripsVertex,
        fs: tripsFragment,
        geometry: new Geometry({
          id: this.props.id,
          drawMode: 'LINES'
        }),
        vertexCount: 0,
        isIndexed: true,
        // TODO-state-management: onBeforeRender can go to settings, onAfterRender, we should
        // move this settings of corresponding draw.
        onBeforeRender: function onBeforeRender() {
          gl.enable(gl.BLEND);
          gl.enable(gl.POLYGON_OFFSET_FILL);
          gl.polygonOffset(2.0, 1.0);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
          gl.blendEquation(gl.FUNC_ADD);
        },
        onAfterRender: function onAfterRender() {
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
          gl.disable(gl.POLYGON_OFFSET_FILL);
        }
      });
    }
  }, {
    key: "countVertices",
    value: function countVertices(data) {
      if (!data) {
        return;
      }

      var getPath = this.props.getPath;
      var vertexCount = 0;
      var pathLengths = data.reduce(function (acc, d) {
        var l = getPath(d).length;
        vertexCount += l;
        return [].concat(_toConsumableArray(acc), [l]);
      }, []);
      this.setState({
        pathLengths: pathLengths,
        vertexCount: vertexCount
      });
    }
  }, {
    key: "draw",
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var _this$props = this.props,
          trailLength = _this$props.trailLength,
          currentTime = _this$props.currentTime;
      this.state.model.render(Object.assign({}, uniforms, {
        trailLength: trailLength,
        currentTime: currentTime
      }));
    }
  }, {
    key: "calculateIndices",
    value: function calculateIndices(attribute) {
      var _this$state = this.state,
          pathLengths = _this$state.pathLengths,
          vertexCount = _this$state.vertexCount;
      var indicesCount = (vertexCount - pathLengths.length) * 2;
      var indices = new Uint32Array(indicesCount);
      var offset = 0;
      var index = 0;

      for (var i = 0; i < pathLengths.length; i++) {
        var l = pathLengths[i];
        indices[index++] = offset;

        for (var j = 1; j < l - 1; j++) {
          indices[index++] = j + offset;
          indices[index++] = j + offset;
        }

        indices[index++] = offset + l - 1;
        offset += l;
      }

      attribute.value = indices;
      this.state.model.setVertexCount(indicesCount);
    }
  }, {
    key: "calculatePositions",
    value: function calculatePositions(attribute) {
      var _this$props2 = this.props,
          data = _this$props2.data,
          getPath = _this$props2.getPath;
      var vertexCount = this.state.vertexCount;
      var positions = new Float32Array(vertexCount * 3);
      var index = 0;

      for (var i = 0; i < data.length; i++) {
        var path = getPath(data[i]);

        for (var j = 0; j < path.length; j++) {
          var pt = path[j];
          positions[index++] = pt[0];
          positions[index++] = pt[1];
          positions[index++] = pt[2];
        }
      }

      attribute.value = positions;
    }
  }, {
    key: "calculateColors",
    value: function calculateColors(attribute) {
      var _this$props3 = this.props,
          data = _this$props3.data,
          getColor = _this$props3.getColor;
      var _this$state2 = this.state,
          pathLengths = _this$state2.pathLengths,
          vertexCount = _this$state2.vertexCount;
      var colors = new Float32Array(vertexCount * 3);
      var index = 0;

      for (var i = 0; i < data.length; i++) {
        var color = getColor(data[i]);
        var l = pathLengths[i];

        for (var j = 0; j < l; j++) {
          colors[index++] = color[0];
          colors[index++] = color[1];
          colors[index++] = color[2];
        }
      }

      attribute.value = colors;
    }
  }]);

  return TripsLayer;
}(Layer);

export { TripsLayer as default };
TripsLayer.layerName = 'TripsLayer';
TripsLayer.defaultProps = defaultProps;
//# sourceMappingURL=trips-layer.js.map