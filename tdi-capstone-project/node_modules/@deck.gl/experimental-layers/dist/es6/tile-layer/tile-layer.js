function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import { GeoJsonLayer, CompositeLayer } from 'deck.gl';
import TileCache from './utils/tile-cache';
const defaultProps = {
  renderSubLayers: props => new GeoJsonLayer(props),
  getTileData: (_ref) => {
    let x = _ref.x,
        y = _ref.y,
        z = _ref.z;
    return Promise.resolve(null);
  },
  onDataLoaded: () => {},
  // eslint-disable-next-line
  onGetTileDataError: err => console.error(err),
  maxZoom: null,
  minZoom: null,
  maxCacheSize: null
};
export default class TileLayer extends CompositeLayer {
  initializeState() {
    const _this$props = this.props,
          maxZoom = _this$props.maxZoom,
          minZoom = _this$props.minZoom,
          getTileData = _this$props.getTileData,
          onGetTileDataError = _this$props.onGetTileDataError;
    this.state = {
      tiles: [],
      tileCache: new TileCache({
        getTileData,
        maxZoom,
        minZoom,
        onGetTileDataError
      }),
      isLoaded: false
    };
  }

  shouldUpdateState(_ref2) {
    let changeFlags = _ref2.changeFlags;
    return changeFlags.somethingChanged;
  }

  updateState(_ref3) {
    let props = _ref3.props,
        oldProps = _ref3.oldProps,
        context = _ref3.context,
        changeFlags = _ref3.changeFlags;
    const onDataLoaded = props.onDataLoaded,
          onGetTileDataError = props.onGetTileDataError;

    if (changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData)) {
      const getTileData = props.getTileData,
            maxZoom = props.maxZoom,
            minZoom = props.minZoom,
            maxCacheSize = props.maxCacheSize;
      this.state.tileCache.finalize();
      this.setState({
        tileCache: new TileCache({
          getTileData,
          maxSize: maxCacheSize,
          maxZoom,
          minZoom,
          onGetTileDataError
        })
      });
    }

    if (changeFlags.viewportChanged) {
      const viewport = context.viewport;
      const z = this.getLayerZoomLevel();

      if (viewport.id !== 'DEFAULT-INITIAL-VIEWPORT') {
        this.state.tileCache.update(viewport, tiles => {
          const currTiles = tiles.filter(tile => tile.z === z);
          const allCurrTilesLoaded = currTiles.every(tile => tile.isLoaded);
          this.setState({
            tiles,
            isLoaded: allCurrTilesLoaded
          });

          if (!allCurrTilesLoaded) {
            Promise.all(currTiles.map(tile => tile.data)).then(() => {
              this.setState({
                isLoaded: true
              });
              onDataLoaded(currTiles.filter(tile => tile._data).map(tile => tile._data));
            });
          } else {
            onDataLoaded(currTiles.filter(tile => tile._data).map(tile => tile._data));
          }
        });
      }
    }
  }

  getPickingInfo(_ref4) {
    let info = _ref4.info,
        sourceLayer = _ref4.sourceLayer;
    info.sourceLayer = sourceLayer;
    info.tile = sourceLayer.props.tile;
    return info;
  }

  getLayerZoomLevel() {
    const z = Math.floor(this.context.viewport.zoom);
    const _this$props2 = this.props,
          maxZoom = _this$props2.maxZoom,
          minZoom = _this$props2.minZoom;

    if (maxZoom && parseInt(maxZoom, 10) === maxZoom && z > maxZoom) {
      return maxZoom;
    } else if (minZoom && parseInt(minZoom, 10) === minZoom && z < minZoom) {
      return minZoom;
    }

    return z;
  }

  renderLayers() {
    // eslint-disable-next-line no-unused-vars
    const _this$props3 = this.props,
          getTileData = _this$props3.getTileData,
          renderSubLayers = _this$props3.renderSubLayers,
          visible = _this$props3.visible,
          geoProps = _objectWithoutProperties(_this$props3, ["getTileData", "renderSubLayers", "visible"]);

    const z = this.getLayerZoomLevel();
    return this.state.tiles.map(tile => {
      return renderSubLayers(_objectSpread({}, geoProps, {
        id: `${this.id}-${tile.x}-${tile.y}-${tile.z}`,
        data: tile.data,
        visible: visible && (!this.state.isLoaded || tile.z === z),
        tile
      }));
    });
  }

}
TileLayer.layerName = 'TileLayer';
TileLayer.defaultProps = defaultProps;
//# sourceMappingURL=tile-layer.js.map